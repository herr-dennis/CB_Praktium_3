/* Generated By:JavaCC: Do not edit this line. MiniJava.java */
import exceptions.ConstantModificationException;
import exceptions.SymbolNotDeclaredException;
import exceptions.SymbolDoesNotExist;
import exceptions.SymbolAlreadyDefinedException;
import exceptions.RwertException;
import exceptions.WrongParametersException;import java.util.ArrayList;

public class MiniJava implements MiniJavaConstants {
    static SymbolTable table = new SymbolTable();
    static CodeErzeugung codeErzeugung = new  CodeErzeugung();
    static TableHandler tableHandler = new TableHandler();
    static ConstantPool constantPool = new ConstantPool();

  static final public void Empty() throws ParseException {

  }

  static final public void programm() throws ParseException, ConstantModificationException, SymbolAlreadyDefinedException, SymbolNotDeclaredException, SymbolDoesNotExist, WrongParametersException, RwertException {
    constDecl();
    varDeclGlobal();
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case VOID:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      procedure();
    }
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FUNC:
        ;
        break;
      default:
        jj_la1[1] = jj_gen;
        break label_2;
      }
      function();
    }
    statement();
   codeErzeugung.add("return");

int jumpToMain = table.getBytesAllMethods()+2;
codeErzeugung.setJumpOverMethod("goto " +Integer.toString(jumpToMain) );
    jj_consume_token(0);
          codeErzeugung.print(); codeErzeugung.translateToOpcodes(); codeErzeugung.printByteCode(); System.out.println(codeErzeugung.getByteCount());
  }

  static final public void constDecl() throws ParseException, ConstantModificationException, SymbolAlreadyDefinedException, SymbolNotDeclaredException, SymbolDoesNotExist, WrongParametersException, RwertException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FINAL:
      jj_consume_token(FINAL);
      jj_consume_token(INT);
      constZuw();
      constList();
      jj_consume_token(24);
      break;
    default:
      jj_la1[2] = jj_gen;
      Empty();
    }
  }

  static final public void constZuw() throws ParseException, ConstantModificationException, SymbolAlreadyDefinedException, SymbolNotDeclaredException, SymbolDoesNotExist, WrongParametersException, RwertException {
    jj_consume_token(IDENT);
            String ide = token.image;
    jj_consume_token(25);
    jj_consume_token(NUMBER);
          int value = Integer.parseInt(token.image);
          // Pr√ºfen, ob eine lokale Tabelle existiert
          SymbolTable currentTable = tableHandler.currentTable();
          if (currentTable != null) {
              currentTable.addConst(ide, value); // In lokale Tabelle eintragen
          } else {
              constantPool.addGlobalVariable(ide);
              table.addConst(ide, value); // In globale Tabelle eintragen
          }
  }

  static final public void constList() throws ParseException, ConstantModificationException, SymbolAlreadyDefinedException, SymbolNotDeclaredException, SymbolDoesNotExist, WrongParametersException, RwertException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 26:
      jj_consume_token(26);
      constZuw();
      constList();
      break;
    default:
      jj_la1[3] = jj_gen;
      Empty();
    }
  }

  static final public void varDeclGlobal() throws ParseException, ConstantModificationException, SymbolAlreadyDefinedException, SymbolNotDeclaredException, SymbolDoesNotExist, WrongParametersException, RwertException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INT:
      jj_consume_token(INT);
      jj_consume_token(IDENT);
                  String ide = token.image;
      varZuwGlobal(ide);
      varListGlobal();
      jj_consume_token(24);
      break;
    default:
      jj_la1[4] = jj_gen;
      Empty();
    }
  }

  static final public void varZuwGlobal(String ide) throws ParseException, ConstantModificationException, SymbolAlreadyDefinedException, SymbolNotDeclaredException, SymbolDoesNotExist, WrongParametersException, RwertException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 25:
      jj_consume_token(25);
      jj_consume_token(NUMBER);
                 table.addVar(ide, Integer.parseInt(token.image));  String index =  constantPool.addGlobalVariable(ide); codeErzeugung.add("bipush "+table.getValue(ide)); codeErzeugung.add("putstatic "+"[g"+ide+"]" );
      break;
    default:
      jj_la1[5] = jj_gen;
      Empty();
    }
  }

  static final public void varListGlobal() throws ParseException, ConstantModificationException, SymbolAlreadyDefinedException, SymbolNotDeclaredException, SymbolDoesNotExist, WrongParametersException, RwertException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 26:
      jj_consume_token(26);
      jj_consume_token(IDENT);
                String ide = token.image;
      varZuwGlobal(ide);
      varListGlobal();
      break;
    default:
      jj_la1[6] = jj_gen;
      Empty();
    }
  }

  static final public void varDeclLocal() throws ParseException, ConstantModificationException, SymbolAlreadyDefinedException, SymbolNotDeclaredException, SymbolDoesNotExist, WrongParametersException, RwertException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INT:
      jj_consume_token(INT);
      jj_consume_token(IDENT);
        String ide = token.image;
      varZuwLocal(ide);
      varListLocal();
      jj_consume_token(24);
      break;
    default:
      jj_la1[7] = jj_gen;
      Empty();
    }
  }

  static final public void varZuwLocal(String ide) throws ParseException, ConstantModificationException, SymbolAlreadyDefinedException, SymbolNotDeclaredException, SymbolDoesNotExist, WrongParametersException, RwertException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 25:
      jj_consume_token(25);
      jj_consume_token(NUMBER);
        SymbolTable localTable = tableHandler.currentTable();
        String methodName = localTable.getCurrentMethodName();
        int anzahlPara = table.getParameterFromMethodPara(methodName);
        localTable.setAddress(anzahlPara);
        localTable.addLocalVar(ide, Integer.parseInt(token.image));
        table.addCodeToMethod(methodName,"bipush " + localTable.getValue(ide) );
        table.addCodeToMethod(methodName,"istore " + localTable.getAddress(ide) );
      break;
    default:
      jj_la1[8] = jj_gen;
      Empty();
    }
  }

  static final public void varListLocal() throws ParseException, ConstantModificationException, SymbolAlreadyDefinedException, SymbolNotDeclaredException, SymbolDoesNotExist, WrongParametersException, RwertException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 26:
      jj_consume_token(26);
      jj_consume_token(IDENT);
        String ide = token.image;
      varZuwLocal(ide);
      varListLocal();
      break;
    default:
      jj_la1[9] = jj_gen;
      Empty();
    }
  }

  static final public void expression() throws ParseException, ConstantModificationException, SymbolAlreadyDefinedException, SymbolNotDeclaredException, SymbolDoesNotExist, WrongParametersException, RwertException {
    term();
    summe();
  }

  static final public void term() throws ParseException, ConstantModificationException, SymbolAlreadyDefinedException, SymbolNotDeclaredException, SymbolDoesNotExist, WrongParametersException, RwertException {
    faktor();
    produkt();
  }

  static final public void summe() throws ParseException, ConstantModificationException, SymbolAlreadyDefinedException, SymbolNotDeclaredException, SymbolDoesNotExist, WrongParametersException, RwertException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PLUS:
      jj_consume_token(PLUS);
      term();
                codeErzeugung.add("iadd");
      summe();
      break;
    case MINUS:
      jj_consume_token(MINUS);
      term();
                  codeErzeugung.add("isub");
      summe();
      break;
    default:
      jj_la1[10] = jj_gen;
      Empty();
    }
  }

  static final public void produkt() throws ParseException, ConstantModificationException, SymbolAlreadyDefinedException, SymbolNotDeclaredException, SymbolDoesNotExist, WrongParametersException, RwertException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case MAL:
      jj_consume_token(MAL);
      faktor();
                  codeErzeugung.add("imul");
      produkt();
      break;
    case DIV:
      jj_consume_token(DIV);
      faktor();
                  codeErzeugung.add("idiv");
      produkt();
      break;
    default:
      jj_la1[11] = jj_gen;
      Empty();
    }
  }

  static final public void faktor() throws ParseException, ConstantModificationException, SymbolAlreadyDefinedException, SymbolNotDeclaredException, SymbolDoesNotExist, WrongParametersException, RwertException, RwertException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NUMBER:
      jj_consume_token(NUMBER);
                if(!tableHandler.localTableExists())
               codeErzeugung.add("bipush " + token.image);
               else {
                   SymbolTable localTable = tableHandler.currentTable();
                   String currentMethod = localTable.getCurrentMethodName(); // Aktuelle Methode bestimmen
                   localTable.addCodeToMethod(currentMethod,"bipush "+token.image);
               }
      break;
    case IDENT:
      jj_consume_token(IDENT);
   SymbolTable localTable_ = tableHandler.currentTable();


       boolean inLocalTable = (localTable_ != null && localTable_.contains(token.image));
       boolean inGlobalTable = table.contains(token.image);
       boolean isMethod = table.containsMethod(token.image);

       if (!inLocalTable && !inGlobalTable && !isMethod) {
           {if (true) throw new RwertException("Bezeichner '" + token.image + "' ist nicht definiert.");}
       }
  String ide = token.image;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case KLAMMERAUF:
        functionCall(token.image);
        break;
      default:
        jj_la1[12] = jj_gen;
        Empty();
      }
             if(tableHandler.localTableExists()||table.contains(token.image)){
             //Pr√ºfe ob es keine LocaleSymbolTabelle gibt
             if (!tableHandler.localTableExists()) {
                 // Variable global -> Pr√ºfe globale Tabelle
                 if (!table.contains(token.image)) {
                     {if (true) throw new SymbolNotDeclaredException();}
                 }
                 if(table.getTyp(token.image).equals("const")){
                  codeErzeugung.add("bipush " + table.getValue(token.image));
                 }else{
                     codeErzeugung.add("getstatic " +"[g"+ide+"]");
                 }
             //Else-Fall, es gibt eine LocaleTabelle!
             } else {
                 // Lokale Tabelle -> Pr√ºfe zuerst lokale, dann globale Tabelle
                 System.out.println("HIER NICHT2");
                 SymbolTable localTable = tableHandler.currentTable();
                 String methodeName = localTable.getCurrentMethodName();
                 if (localTable.contains(token.image)) {
                      if(localTable.getTyp(token.image).equals("const")){
                          table.addCodeToMethod ( methodeName, "bipush " + localTable.getValue(token.image));}
                      else{
                          table.addCodeToMethod ( methodeName, "iload " + localTable.getAddress(token.image));}

                 } else if (table.contains(token.image)) {
                     // Fallback auf globale Tabelle
                      if(table.getTyp(token.image).equals("const")){
                          codeErzeugung.add("bipush " + table.getValue(token.image));}
                      else{

                          codeErzeugung.add("iload " + table.getAddress(token.image));}
                 } else {
                     {if (true) throw new SymbolNotDeclaredException();}
                 }
             }
         }
      break;
    case KLAMMERAUF:
      jj_consume_token(KLAMMERAUF);
      expression();
      jj_consume_token(KLAMMERZU);
      break;
    default:
      jj_la1[13] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void statement() throws ParseException, ConstantModificationException, SymbolAlreadyDefinedException, SymbolNotDeclaredException, SymbolDoesNotExist, WrongParametersException, RwertException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENT:
      jj_consume_token(IDENT);
        String ide = token.image;
        if (table.getTyp(ide)!=null && table.getTyp(ide).equals("const")) {
            {if (true) throw new ConstantModificationException();}
        }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 25:
        jj_consume_token(25);
        expression();
         if (!tableHandler.localTableExists()){
             codeErzeugung.add("getstatic " +"[g"+ide+"]");
         }
         else{
             SymbolTable localTable = tableHandler.currentTable();
             String methodeName = localTable.getCurrentMethodName();
             table.addCodeToMethod(methodeName,"istore " +table.getAddress(ide));

         }
        break;
      case KLAMMERAUF:
        procCall(ide);
        break;
      default:
        jj_la1[14] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(24);
      break;
    case PRINT:
      jj_consume_token(PRINT);
      jj_consume_token(KLAMMERAUF);
      expression();
      if (!tableHandler.localTableExists()){
          codeErzeugung.add("print 00 23");
      }
      else {
           SymbolTable localTable = tableHandler.currentTable();
           String methodeName = localTable.getCurrentMethodName();
           table.addCodeToMethod(methodeName,"print 00 23") ;
      }
      jj_consume_token(KLAMMERZU);
      jj_consume_token(24);
      break;
    case IF:
      jj_consume_token(IF);
      int vor_condition_if = codeErzeugung.getByteCount();
      condition();
       int nach_condition_if =codeErzeugung.getByteCount()-2;
      statement();
      int nach_state_if = codeErzeugung.getByteCount();
     int if_anweisung_if = (nach_state_if) - (nach_condition_if-1);
      codeErzeugung.insertAddress(Integer.toString(if_anweisung_if));
      //codeErzeugung.add("goto " +gotoStrung);

      optElse();
      break;
    case 27:
      jj_consume_token(27);
      stmtLIST();
      jj_consume_token(28);
      break;
    case WHILE:
      jj_consume_token(WHILE);
            int vor_condition = codeErzeugung.getByteCount();
      condition();
        int nach_condition =codeErzeugung.getByteCount()-2;
      statement();
            int nach_Statement = codeErzeugung.getByteCount();
            // Berechnung f√ºr goto-Sprung
            int gotoStrung = vor_condition - nach_Statement ;
            codeErzeugung.add("goto " +gotoStrung);
            int nach_goto = codeErzeugung.getByteCount();
            //if sprung
            int if_anweisung = (nach_goto) - (nach_condition-1);
             // Zieladresse f√ºr Bedingung setzen (if-Anweisung)
            codeErzeugung.insertAddress(Integer.toString(if_anweisung));
      break;
    default:
      jj_la1[15] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void stmtLIST() throws ParseException, ConstantModificationException, SymbolAlreadyDefinedException, SymbolNotDeclaredException, SymbolDoesNotExist, WrongParametersException, RwertException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WHILE:
    case IF:
    case PRINT:
    case IDENT:
    case 27:
      statement();
      stmtLIST();
      break;
    default:
      jj_la1[16] = jj_gen;
      Empty();
    }
  }

  static final public void optElse() throws ParseException, ConstantModificationException, SymbolAlreadyDefinedException, SymbolNotDeclaredException, SymbolDoesNotExist, WrongParametersException, RwertException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ELSE:
      jj_consume_token(ELSE);
  int bevor_else = codeErzeugung.getByteCount();
      statement();
  int else_state = codeErzeugung.getByteCount()-bevor_else;
    //codeErzeugung.insertAdress("goto else_state");

      break;
    default:
      jj_la1[17] = jj_gen;
      Empty();
    }
  }

  static final public void condition() throws ParseException, ConstantModificationException, SymbolAlreadyDefinedException, SymbolNotDeclaredException, SymbolDoesNotExist, WrongParametersException, RwertException {
    expression();
    jj_consume_token(ComOp);
                      String compOp =token.image;
    expression();
    boolean existsLocalTable = false;
    SymbolTable localTable = null;
    String methodeName = null;

    // √úberpr√ºfen, ob eine lokale Tabelle existiert
    if (tableHandler.localTableExists()) {
        existsLocalTable = true;
        localTable = tableHandler.currentTable();
        methodeName = localTable.getCurrentMethodName();
    }

    // Switch-Fallunterscheidung f√ºr Vergleichsoperatoren
    switch (compOp) {
        case "<":
            if (existsLocalTable) {
                table.addCodeToMethod(methodeName, "if_icmpge -1");
            } else {
                codeErzeugung.add("if_icmpge -1"); // F√ºr globale Tabelle
            }
            break;
        case "<=":
            if (existsLocalTable) {
                table.addCodeToMethod(methodeName, "if_icmpgt -1");
            } else {
                codeErzeugung.add("if_icmpgt -1");
            }
            break;
        case ">":
            if (existsLocalTable) {
                table.addCodeToMethod(methodeName, "if_icmple -1");
            } else {
                codeErzeugung.add("if_icmple -1");
            }
            break;
        case ">=":
            if (existsLocalTable) {
                table.addCodeToMethod(methodeName, "if_icmplt -1");
            } else {
                codeErzeugung.add("if_icmplt -1");
            }
            break;
        case "==":
            if (existsLocalTable) {
                table.addCodeToMethod(methodeName, "if_icmpne -1");
            } else {
                codeErzeugung.add("if_icmpne -1");
            }
            break;
        case "!=":
            if (existsLocalTable) {
                table.addCodeToMethod(methodeName, "if_icmpeq -1");
            } else {
                codeErzeugung.add("if_icmpeq -1");
            }
            break;
        default:
            {if (true) throw new IllegalArgumentException("Ung\u00fcltiger Vergleichsoperator: " + compOp);}
    }
  }

  static final public void procedure() throws ParseException, ConstantModificationException, SymbolAlreadyDefinedException, SymbolNotDeclaredException, SymbolDoesNotExist, WrongParametersException, RwertException {
    jj_consume_token(VOID);
    jj_consume_token(IDENT);
                String ide = token.image; tableHandler.createTable(ide); table.addMethod(ide, "void");
    jj_consume_token(KLAMMERAUF);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INT:
      routinenParameter(ide);
      break;
    default:
      jj_la1[18] = jj_gen;
      Empty();
    }
    jj_consume_token(KLAMMERZU);
    jj_consume_token(27);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FINAL:
    case INT:
    case WHILE:
    case IF:
    case PRINT:
    case IDENT:
    case 27:
      routinenBlock();
      break;
    default:
      jj_la1[19] = jj_gen;
      Empty();
    }
    jj_consume_token(28);
      table.addCodeToMethod(ide, "return");
      constantPool.addMethod(ide,"void", table.getParameterFromMethodPara(ide));
      ArrayList<String> methodCode = table.getByteCodeForMethod(ide);
      codeErzeugung.insertMethodCode(methodCode);
      tableHandler.removeCurrentTable();
  }

  static final public void function() throws ParseException, ConstantModificationException, SymbolAlreadyDefinedException, SymbolNotDeclaredException, SymbolDoesNotExist, WrongParametersException, RwertException {
    jj_consume_token(FUNC);
    jj_consume_token(IDENT);
                 String ide = token.image; tableHandler.createTable(ide); table.addMethod(ide, "func");
    jj_consume_token(KLAMMERAUF);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INT:
      routinenParameter(ide);
      break;
    default:
      jj_la1[20] = jj_gen;
      Empty();
    }
    jj_consume_token(KLAMMERZU);
    jj_consume_token(27);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FINAL:
    case INT:
    case WHILE:
    case IF:
    case PRINT:
    case IDENT:
    case 27:
      routinenBlock();
      break;
    default:
      jj_la1[21] = jj_gen;
      Empty();
    }
    jj_consume_token(RETURN);
    expression();
    jj_consume_token(24);
    jj_consume_token(28);
table.addCodeToMethod(ide, "ireturn");
constantPool.addMethod(ide,"int", table.getParameterFromMethodPara(ide));

ArrayList<String> methodCode = table.getByteCodeForMethod(ide);
codeErzeugung.insertMethodCode(methodCode);
tableHandler.removeCurrentTable();
  }

  static final public void routinenParameter(String ide) throws ParseException, ConstantModificationException, SymbolAlreadyDefinedException, SymbolNotDeclaredException, SymbolDoesNotExist, WrongParametersException, RwertException {
 SymbolTable symbolTable = tableHandler.currentTable(); int para = 0;
    jj_consume_token(INT);
    jj_consume_token(IDENT);
                  para = para +1;
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 26:
        ;
        break;
      default:
        jj_la1[22] = jj_gen;
        break label_3;
      }
      jj_consume_token(26);
      jj_consume_token(INT);
      jj_consume_token(IDENT);
                                                          para = para +1;
    }
  table.addMethodPara(ide, para);
  }

  static final public void routinenBlock() throws ParseException, ConstantModificationException, SymbolAlreadyDefinedException, SymbolNotDeclaredException, SymbolDoesNotExist, WrongParametersException, RwertException {
    constDecl();
    varDeclLocal();
    statement();
  }

  static final public void functionCall(String ide) throws ParseException, ConstantModificationException, SymbolAlreadyDefinedException, SymbolNotDeclaredException, SymbolDoesNotExist, WrongParametersException, RwertException {
     int anzahlPara = 0;
    jj_consume_token(KLAMMERAUF);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NUMBER:
    case KLAMMERAUF:
    case IDENT:
      expression();
                   anzahlPara++;
      label_4:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 26:
          ;
          break;
        default:
          jj_la1[23] = jj_gen;
          break label_4;
        }
        jj_consume_token(26);
        expression();
                                                    anzahlPara++;
      }
      break;
    default:
      jj_la1[24] = jj_gen;
      Empty();
    }
    jj_consume_token(KLAMMERZU);
    varDeclLocal();
     int methodPara = table.getActuallyMethodPara(ide);
    if(methodPara!=anzahlPara){
      {if (true) throw new WrongParametersException();}
    }

    codeErzeugung.add("invokestatic "+ 11);
  }

  static final public void procCall(String ide) throws ParseException, ConstantModificationException, SymbolAlreadyDefinedException, SymbolNotDeclaredException, SymbolDoesNotExist, WrongParametersException, RwertException {
     int anzahlPara = 0;
    jj_consume_token(KLAMMERAUF);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NUMBER:
    case KLAMMERAUF:
    case IDENT:
      expression();
                       anzahlPara++;
      label_5:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 26:
          ;
          break;
        default:
          jj_la1[25] = jj_gen;
          break label_5;
        }
        jj_consume_token(26);
        expression();
                                                        anzahlPara++;
      }
      break;
    default:
      jj_la1[26] = jj_gen;
      Empty();
    }
    jj_consume_token(KLAMMERZU);
    varDeclLocal();
         int methodPara = table.getActuallyMethodPara(ide);
        if(methodPara!=anzahlPara){
          {if (true) throw new WrongParametersException();}
        }
        codeErzeugung.add("invokestatic "+ 11);
  }

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public MiniJavaTokenManager token_source;
  static SimpleCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[27];
  static private int[] jj_la1_0;
  static {
      jj_la1_init_0();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x800,0x1000,0x20,0x4000000,0x40,0x2000000,0x4000000,0x40,0x2000000,0x4000000,0xc0000,0x300000,0x10000,0x814000,0x2010000,0x8800580,0x8800580,0x200,0x40,0x88005e0,0x40,0x88005e0,0x4000000,0x4000000,0x814000,0x4000000,0x814000,};
   }

  /** Constructor with InputStream. */
  public MiniJava(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public MiniJava(java.io.InputStream stream, String encoding) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new MiniJavaTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 27; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 27; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public MiniJava(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new MiniJavaTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 27; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 27; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public MiniJava(MiniJavaTokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 27; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(MiniJavaTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 27; i++) jj_la1[i] = -1;
  }

  static private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List jj_expentries = new java.util.ArrayList();
  static private int[] jj_expentry;
  static private int jj_kind = -1;

  /** Generate ParseException. */
  static public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[29];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 27; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 29; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

}
